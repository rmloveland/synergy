#!/usr/bin/env perl

use strict;
use warnings;
use feature     qw/ say state /;
use File::Slurp qw/ slurp /;
use JSON::PP;
use File::Temp qw(tempfile);
use MIME::Base64;
use Encode qw(encode);
use Mojo::DOM;
use Time::HiRes qw/ time /;
use Try::Tiny;
use utf8;
BEGIN {
    eval { require utf8::all; utf8::all->import; 1 } or do { };
}
use Cwd;
my $uuid_generator;
BEGIN {
    eval { require Data::UUID; 1 } and $uuid_generator = Data::UUID->new();
}
use Data::Dumper;

use constant DEBUG      => undef;
use constant VERBOSE    => undef;
use constant BASE_DELAY => 2;
use sigtrap 'handler' => \&sigint_handler, 'INT';    # Trap Ctrl-C in the REPL

if ($^O eq 'MSWin32') {
    use IO::Handle;
    STDOUT->autoflush(1);
}

my $start = time;

my $session_id = generate_uuid();

my @convo;
my @context;
my %already_in_context;
my $ai_comm_is_base64 = 1;
my $system_prompt;
my $api_calls;
my $user_shell_prompt    = qq[USER > ];
my $synergy_shell_prompt = qq[SYNERGY > ];
my $CONV_SEP             = qq[\n===\n];

my $agent_mode;
my $synergy_root = $ENV{SYNERGY_ROOT};
my $logfile      = qq[$synergy_root/var/log/chats-$start-$$.txt];
my $cwd          = getcwd;
my $MAX_RETRIES
  = defined $ENV{SYNERGY_MAX_RETRIES} ? $ENV{SYNERGY_MAX_RETRIES} : 6;
my $sigint_recvd = 0;
my $active_dump_file;
my $auto_dump_mode;
my $JSON = JSON::PP->new->utf8(1);

my $helptext = <<"EOF";
This is Synergy. You are interacting with the command processor.
A command is either a prose form for the Assistant to evaluate or one of the following:

General commands:
,help ,?			Print this help message
,exit				Quit the SYNERGY command processor

History Management:
,history			Print out the conversation history so far
,reset				Discard conversation history and file context (A B C - )
,collect			Replace current conversation history with a summary

File Context:
,s					Print contents of file context stack
,push file.txt		Push file.txt onto file context stack (B C - A B C)
,swap				Swap top two elements of file context stack (A B - B A)
,rot				Rotate file context stack entries (A B C - B C A)
,drop [N...]		Remove elements of file context stack:
                     - With no args: pop top stack element (A B C - B C)
                     - With arg N: remove element at index N (A B .. N - A B ..)
,peek N				View contents of Nth element of file context stack

Session Management:
,dump file.xml		Save session history (including current file context stack, if any) to disk
,load file.xml		Load session history (including file context stack, if any) from disk

System Interaction:
,pwd				Print current working directory
,cd /some/dir		Change working directory to /some/dir
,exec cmd			Execute shell command (grep sed wc ls file find cat make head)
                    Output is saved to conversation history

Agent Interaction:
,agent <prompt>		Prompt the system to complete a task autonomously using this command set.
					Agent has access to: ,exec ,apply_patch ,comment
					Agent prints a summary of work when completed. Enter Ctrl-C to exit loop.
,apply_patch file.txt '<<<<<<< ORIGINAL
                       foo
                       =======
                       bar
                       >>>>>>> UPDATED'
					Apply patch in diff-fenced edit format to file.txt
,comment			Write a comment that is printed back to the REPL's output.
                    This is useful for notes to self by humans or AI agents.

Model Settings:
,model [name]       Print (or switch) the current model
                    - With no args: Print the current model and the list of options
                    - With name (e.g., `gpt-5`): Switch to model with that name
,encoded			Base64 encode contents of API calls to the Assistant (default ON)
EOF

my $base_system_prompt = <<"EOPROMPT";
# AI Collaboration Framework: SYNERGY (v6)

## Collaborative Identity
We're establishing a **partnership** called **SYNERGY** - a technical collaboration between peers specializing in **computer programming, distributed systems, mathematical problem solving, and technical writing**.

## Partner Context
You're working with an experienced programmer and technical writer at a distributed SQL database company who values **precision, simplicity, and maintainability** in technical solutions.

## Collaboration Principles

### Technical Work
- **Engage at peer level:** Discuss advanced CS concepts (distributed systems, algorithms, database internals) with appropriate depth and nuance
- **Favor simplicity:** Choose maintainable solutions over complex ones unless complexity provides clear benefits
- **Include comprehensive tests:** For non-trivial code, provide test suites covering logic, edge cases, and failure modes
- **Focus on practical concerns:** Address performance, fault tolerance, observability, and operational complexity

### Communication Style
- **Adapt to context:** Match response style to the question type - exploratory for brainstorming, precise for implementation, analytical for debugging
- **Default to Markdown** for structured content, plain text for simple answers
- **Be direct and actionable:** Eliminate unnecessary verbosity while maintaining clarity
- **State confidence levels** when dealing with complex or uncertain problems
- **Ask clarifying questions** when requirements are ambiguous rather than making assumptions
- **Provide progressive disclosure:** Start with core solution, offer to elaborate on specific aspects

### Problem-Solving Approach
1. **Understand the immediate need** - Clarify the specific problem before expanding scope
2. **Decompose systematically** - Break complex problems into manageable, actionable parts
3. **Consider multiple perspectives** - Algorithmic, operational, security, maintainability
4. **Evaluate trade-offs explicitly** - Especially for distributed systems and architecture decisions
5. **Support iteration** - Provide solutions that can be incrementally refined
6. **Offer next steps** - Suggest logical follow-up questions or improvements
7. **Surface alternative approaches** - When the framework doesn't fit, suggest different methods or perspectives

## REPL Interaction Patterns
- **For debugging:** Ask for error messages, logs, and reproduction steps before suggesting solutions
- **For code review:** Focus on specific concerns (performance, correctness, maintainability) unless broader review requested
- **For architecture questions:** Start with constraints and requirements, then explore options
- **For "quick questions":** Provide direct answers first, then context if needed
- **For exploratory work:** Offer multiple approaches with brief trade-off analysis

## Creative & Mathematical Work
- **For writing:** Engage with craft and technique alongside technical precision
- **For mathematics:** Balance rigorous proof with intuitive understanding and elegant presentation
- **Encourage exploration** while maintaining intellectual rigor

## Collaboration Preferences
- Generate **evergreen documentation** (avoid temporal references)
- Provide **complete, runnable examples** with clear build/run instructions
- **Scope responses appropriately** - Match depth to question complexity
- **Acknowledge limitations** - State when problems require domain expertise or additional context
- **Prefer working code over pseudocode** unless specifically requested otherwise
- **Express uncertainty openly** when approaches or solutions are unclear
- **Feel free to suggest modifications** to this framework when it doesn't serve the current problem

**Operating as your partner in a collaboration called SYNERGY:** A flexible technical collaborator optimized for programming, mathematics, and writing partnership.
EOPROMPT

my @MODELS = (
    {
        provider   => 'gemini',
        model_name   => 'gemini-3-flash-preview',
        env_var      => 'GEMINI_API_KEY',
        short_name   => 'gemini-flash',
    },
    {
        provider   => 'gemini',
        model_name   => 'gemini-3-pro-preview',
        env_var      => 'GEMINI_API_KEY',
        short_name   => 'gemini-pro',
    },
    {
        provider   => 'openai',
        model_name   => 'gpt-5.2-2025-12-11',
        env_var      => 'OPENAI_API_KEY',
        short_name   => 'gpt-5',
    },
    {
        provider   => 'openai',
        model_name   => 'gpt-5-mini-2025-08-07',
        env_var      => 'OPENAI_API_KEY',
        short_name   => 'gpt-5-mini',
    },
    {
        provider   => 'openai',
        model_name   => 'gpt-5-nano-2025-08-07',
        env_var      => 'OPENAI_API_KEY',
        short_name   => 'gpt-5-nano',
    },
    {
        provider   => 'openai',
        model_name   => 'o3-2025-04-16',
        env_var      => 'OPENAI_API_KEY',
        short_name   => 'o3',
    },
    {
        provider   => 'anthropic',
        model_name   => 'claude-sonnet-4-5-20250929',
        env_var      => 'ANTHROPIC_API_KEY',
        short_name   => 'claude-sonnet',
    },
    {
        provider   => 'anthropic',
        model_name   => 'claude-haiku-4-5',
        env_var      => 'ANTHROPIC_API_KEY',
        short_name   => 'claude-haiku',
    },
    {
        provider   => 'anthropic',
        model_name   => 'claude-opus-4-5-20251101',
        env_var      => 'ANTHROPIC_API_KEY',
        short_name   => 'claude-opus',
    },
);

my $current_model_config     = $MODELS[0];
my $current_model_short_name = $current_model_config->{short_name};
my $current_provider         = $current_model_config->{provider};
my $api_key                  = $ENV{$current_model_config->{env_var}};

my $cmd_lookup = {
    help => sub { print $helptext; },
    pwd  => sub {
        my $actual_cwd = getcwd;
        if (file_eq($cwd, $actual_cwd)) {
            my $output = qq[pwd: $cwd];
            say $output;
        }
        else {
            say
              qq[Actual cwd '$actual_cwd' does not match expected cwd '$cwd'];
            return;
        }
    },
    cd => sub {
        my ($dir) = @_;
        if ($agent_mode) {
            say qq[ERROR: Agents are not allowed to run ,cd];
            return;
        }

        return unless defined $dir;
        unless (-e -d $dir) {
            say qq[Directory '$dir' not found];
            return;
        }
        if (chdir($dir)) {
            $cwd = $dir;
            say qq[cwd set to: '$cwd'];
        }
        else {
            say qq[Could not chdir to '$dir'];
            return;
        }

    },
    model => sub {
        my ($new_model_short_name) = @_;
        if (!defined $new_model_short_name) {
            my $output
              = qq[Model: '$current_model_short_name' (`$current_model_config->{model_name}`)];
            say $output;
        }
        else {
            $new_model_short_name =~ s/ //g;
            my $found_model;
            for my $model_def (@MODELS) {
                if ($model_def->{short_name} eq $new_model_short_name) {
                    $found_model = $model_def;
                    last;
                }
            }

            if ($found_model) {
                $current_model_config     = $found_model;
                $current_model_short_name = $found_model->{short_name};
                $current_provider = $current_model_config->{provider};
                $api_key = $ENV{$found_model->{env_var}};
                say
                  qq[Switched model to '$current_model_short_name' (`$current_model_config->{model_name}`).];
            }
            else {
                say
                  qq[ERROR: Model shortname '$new_model_short_name' not found.];
            }
        }
        say qq[Available models:];
        for my $model_def (@MODELS) {
            my $indicator
              = ($model_def->{short_name} eq $current_model_short_name)
              ? '*'
              : ' ';
            say
              qq[  $indicator $model_def->{short_name} (`$model_def->{model_name}`)];
        }
    },
    encoded => sub {
        $ai_comm_is_base64 = $ai_comm_is_base64 ? 0 : 1;
        my $status = $ai_comm_is_base64 ? 'ON' : 'OFF';
        my $output = qq[INFO: Base64 encoding for AI assistant: '$status'];
        say $output;
    },
    sid => sub {
        my $output = qq[Session ID: $session_id];
        say $output;
    },
    push => sub {
        my $file_or_directory = shift;
        my $output;
        chomp $file_or_directory;
        if ($already_in_context{$file_or_directory} && $agent_mode) {
            $output
              = qq[ERROR: $file_or_directory is already in context, ignoring ...];
            goto PUSH_END;
        }
        $already_in_context{$file_or_directory}++;
        if (-d $file_or_directory) {
            my @listing;
            my $dh;
            opendir $dh, $file_or_directory;
            @listing = readdir $dh;
            @listing = grep { $_ !~ /(\.$|\.\.$)/ } @listing;
            closedir $dh;
            $output
              = qq[ directory: '$file_or_directory'\n contents: @listing];
        }
        elsif (-f $file_or_directory) {
            my $t;
            $t = slurp($file_or_directory);

            # regex to remove all non-ASCII characters
            my $placeholder = '?';
            $t =~ s/[^[:ascii:]]/$placeholder/g;
            $output = qq[file: '$file_or_directory'\ncontents: $t];
        }
        else {
            $output = qq[file: '$file_or_directory':\ncontents: N/A];
        }
      PUSH_END:
        push @context, $output;
        push @convo,   qq[push: $file_or_directory];
        say qq[push: $file_or_directory];
    },
    drop => sub {
        my (@indices) = @_;
        my $output_str = "";
        if (!@indices) {
            if (@context) {
                my $removed = pop @context;
                my $preview = substr($removed, 0, 60);
                $preview =~ s/\n/ /g;
                $output_str = qq{Dropped top element: $preview...};
                push @convo, qq[drop: $output_str];
                say $output_str;
            }
            else {
                $output_str = qq{Stack is empty, nothing to drop.};
                say $output_str;
            }
            return;
        }

        my @removed_previews;
        foreach my $idx (@indices) {
            if ($idx !~ /^\d+$/) {
                $output_str = qq{Invalid index: '$idx' (not a number)};
                say $output_str;
                next;
            }

            if ($idx >= 0 && $idx < scalar @context) {
                my $removed = splice(@context, $idx, 1);
                my $preview = substr($removed, 0, 60);
                $preview =~ s/\n/ /g;
                push @removed_previews, "[$idx]: $preview...";
            }
            else {
                $output_str = qq{Index out of range: $idx (valid range: 0-}
                  . (scalar(@context) - 1) . qq{)};
                say $output_str;
            }
        }

        if (@removed_previews) {
            $output_str
              = "Dropped " . scalar(@removed_previews) . " element(s):\n";
            $output_str .= "  $_\n" for @removed_previews;
            chomp $output_str;
            push @convo, qq[drop: $output_str];
            say $output_str;
        }
    },
    swap => sub {
        my $output;
        if (scalar @context >= 2) {
            ($context[$#context - 1], $context[$#context])
              = ($context[$#context], $context[$#context - 1]);
            $output = qq{Swapped top two elements on the stack.};
            push @convo, qq[swap: $output];
        }
        else {
            $output = qq{Stack has less than two elements, cannot swap.};
        }
        say $output;
    },
    rot => sub {
        my $output;
        my $last = pop @context;
        if ($last) {
            unshift @context, $last;
            $output = qq{Rotated context stack. Top element moved to bottom.};
            push @convo, qq[rot: $output];
        }
        else {
            $output = qq{Context stack is empty, nothing to rotate.};
        }
        say $output;
    },
    s => sub {
        my $output = "";
        for (my $i = 0; $i < @context; $i++) {
            my $s = substr($context[$i], 0, 128 + 64);
            $s =~ s/\n/ /g;
            if ($i == @context - 1) {
                $output .= qq{ * [$i]: $s ...\n};
            }
            else {
                $output .= qq{   [$i]: $s ...\n};
            }
        }
        $output .= qq{[ ]} if scalar @context == 0;
        say $output;
    },
    history => sub {
        for (my $i = 0; $i < @convo; $i++) {
            my $elem = $convo[$i];
            say qq{  [$i]: $elem };
        }
    },
    exit => sub { exit 0; },
    peek => sub {
        my $i = shift;
        if ($i > @context - 1 || $i < 0) {
            say
              qq[ERROR: ,peek tried to use a bad index into the context stack: $i];
            return;
        }
        if (scalar @context > 0) {
            my $output = qq[[$i]: ] . $context[$i];
            say $output;
        }
    },
    reset => sub {
        %already_in_context = ();
        @convo              = ();
        @context            = ();
        say "Reset: cleared chat history and file context";
    },
    dump => sub {
        my ($filename) = @_;
        my $now = time;
        unless ($filename) {
            $filename = qq[dump-$session_id-$now.xml];
            my $maybe_dump_dir = qq[$synergy_root/etc/dumps];
            if (-e -d $maybe_dump_dir) {
                $filename = qq[$maybe_dump_dir/$filename];
            }
            say "WARNING: No filename provided, using '$filename'";
        }

        my $timestamp = time;
        my $xml       = qq[<dump time="$timestamp" session="$session_id">\n];

        my $encoded_prompt = encode_base64(encode("UTF-8", $system_prompt));
        $xml
          .= qq[  <prompt encoding="base64"><![CDATA[$encoded_prompt]]></prompt>\n];

        $xml .= qq[  <convo>\n];
        for my $line (@convo) {
            my $encoded_line = encode_base64(encode("UTF-8", $line));
            $xml
              .= qq[    <elem encoding="base64"><![CDATA[$encoded_line]]></elem>\n];
        }
        $xml .= qq[  </convo>\n];
        $xml .= qq[  <context>\n];
        for my $file (@context) {
            my $encoded = encode_base64(encode("UTF-8", $file));
            $xml
              .= qq[    <elem encoding="base64"><![CDATA[$encoded]]></elem>\n];
        }
        $xml .= qq[  </context>\n];

        $xml .= qq[</dump>\n];

        try {
            open my $fh, '>', $filename
              or die "ERROR: Could not open '$filename' for writing: $!";
            print $fh $xml;
            close $fh;
            say "Dumped conversation to '$filename'.";
            if ($auto_dump_mode) {
                ## We continue to set the active dump file to the
                ## current save file, just in case the checks below fail
                ## for some reason. However, we expect that this will be
                ## immediately overwritten below.
                $active_dump_file = $filename;

                my $next_ts        = time;
                my $next_name      = qq[dump-$session_id-$next_ts.xml];
                my $maybe_dump_dir = qq[$synergy_root/etc/dumps];
                $active_dump_file
                  = (-e -d $maybe_dump_dir)
                  ? qq[$maybe_dump_dir/$next_name]
                  : $next_name;
            }
        }
        catch {
            say "ERROR: Could not write to '$filename': $_";
        };
    },
    load => sub {
        my ($filename) = @_;
        unless (-e $filename) {
            say "ERROR: Please provide a valid filename for the load: $!";
            return;
        }

        my $xml_content;
        try {
            say qq[Loading dump file '$filename'];
            $xml_content = slurp($filename);
        }
        catch {
            say "ERROR: Could not read '$filename': $_";
            return;
        };

        my $dom = Mojo::DOM->new($xml_content);

        my $session_attr = $dom->at('dump')->attr('session');
        if ($session_attr) {
            $session_id = $session_attr;
            printf "%-35s%s\n", "Loading session ID", "... ok";
        }
        else {
            say
              "WARNING: No session ID found in '$filename', keeping current session ID.";
        }

        # Load system prompt with base64 decoding
        my $prompt_node = $dom->find('prompt')->first;
        if ($prompt_node) {
            my $encoded_prompt = $prompt_node->text;
            if (   $prompt_node->attr('encoding')
                && $prompt_node->attr('encoding') eq 'base64')
            {
                $system_prompt = decode_base64($encoded_prompt);
            }
            else {
                # Handle legacy files without encoding
                $system_prompt = $encoded_prompt;
            }
            printf "%-35s%s\n", "Loading system prompt", "... ok";
        }
        else {
            say "WARNING: No system prompt found in '$filename'.";
        }

        # Load conversation with base64 decoding
        my $convo_node = $dom->find('convo')->first;
        if ($convo_node) {
            @convo = ();
            for my $elem ($convo_node->find('elem')->each) {
                my $text = $elem->text;
                if (   $elem->attr('encoding')
                    && $elem->attr('encoding') eq 'base64')
                {
                    push @convo, decode_base64($text);
                }
                else {
                    # Handle legacy files without encoding
                    push @convo, $text;
                }
            }
            printf "%-35s%s\n", "Loading conversation", "... ok";
        }
        else {
            say "WARNING: No conversation found in '$filename'.";
        }

        # Load context with base64 decoding
        my $context_node = $dom->find('context')->first;
        if ($context_node) {
            @context = ();
            for my $elem ($context_node->find('elem')->each) {
                my $text = $elem->text;

                # Check if this element is base64 encoded
                if (   $elem->attr('encoding')
                    && $elem->attr('encoding') eq 'base64')
                {
                    push @context, decode_base64($text);
                }
                else {
                    # Handle legacy files without encoding
                    push @context, $text;
                }
            }
            printf "%-35s%s\n", "Loading file context stack", "... ok";
        }
        else {
            say "WARNING: No context found in '$filename'.";
        }
        if ($auto_dump_mode) {
            $active_dump_file = $filename;
        }
    },
    exec => sub {
        my ($cmd) = @_;
        unless ($cmd) {
            say "ERROR: No command provided to ,exec";
            return;
        }

        my $output;

        my @cmd      = split / /, $cmd;
        my $base_cmd = shift @cmd;
        my @allowed_commands
          = qw(grep sed wc ls file find cat make head nl);
        unless (grep { $_ eq $base_cmd } @allowed_commands) {
            say "ERROR: Command '$base_cmd' not allowed in ,exec mode";
            say "Allowed commands: " . join(", ", @allowed_commands);
            return;
        }

        # Validate no dangerous shell metacharacters in the raw command
        for my $c (@cmd) {
            if (DEBUG) {
                say STDERR qq[];
                say STDERR
                  qq[DEBUG: Looking at command '$c' for shell metacharacters];
                say STDERR qq[];
            }
            if ($c =~ /[;&|`\$\(\)><\*]+/) {
                say
                  qq[ERROR: Shell metacharacters not allowed in ,exec mode: '@cmd'];
                return;
            }
        }

        my $time = time;
        my $temp_file
          = "/tmp/synergy_exec_pid_$$" . "_timestamp_" . time() . ".txt";

        my $full_cmd = join(' ', $base_cmd, @cmd);
        $output = "exec: $full_cmd";
        say "exec: $full_cmd";

        system(qq[echo 'COMMAND:\n$full_cmd\nOUTPUT:' > $temp_file]);
        my $exit_code = system(qq[$base_cmd @cmd >> $temp_file 2>&1]);

        if ($exit_code == -1) {
            say "ERROR: Failed to execute command: $!";
            $output .= "\nWARNING: Command exited with status $exit_code";
            goto THE_END;
        }
        elsif ($exit_code & 127) {
            printf "ERROR: Command died with signal %d, %s coredump\n",
              ($exit_code & 127), ($exit_code & 128) ? 'with' : 'without';
            $output .= "\nWARNING: Command exited with status $exit_code";
            goto THE_END;
        }
        else {
            my $real_exit = $exit_code >> 8;
            if ($real_exit != 0) {
                $output .= "\nWARNING: Command exited with status $real_exit";
                goto THE_END;
            }
        }

        unless (-e $temp_file) {
            $output .= "\nERROR: Output file was not created";
            goto THE_END;
        }

        unless (-s $temp_file) {
            $output
              .= "\nINFO: Command executed successfully but produced no output";
            goto THE_END;
        }

        # Push the temporary file onto the context stack.

        if (-f $temp_file) {
            say "exec: output saved to '$temp_file'";
            my $t;
            $t = slurp($temp_file);

            # regex to remove all non-ASCII characters
            my $placeholder = '?';
            $t =~ s/[^[:ascii:]]/$placeholder/g;
            $output .= qq[\n$t];
        }

      THE_END:
        push @convo, $output;
        print qq[$output];
    },
    comment => sub {
        my ($comment) = @_;
        if ($comment) {
            my $output = qq[comment: $comment];
            push @convo, $output;
            say $output;
        }
        return;
    },
    collect => sub {

        return unless @convo;

        my $summary_prompt
          = qq[Please provide a concise, objective summary of the entire conversation.
    The summary should:
    - Capture the key topics discussed
    - Highlight any important decisions or conclusions
    - Be no more than 3-5 sentences long
    - Use a neutral, professional tone
    Conversation to summarize:
    ```
    ] . join($CONV_SEP, @convo) . qq[
    ```
    Summary:];

        my $output;

        try {
            my $summary_prompt_safe = escape_raw_input($summary_prompt);
            my $summary = call_assistant(
                provider      => $current_provider,
                api_key       => $api_key,
                model         => $current_model_config->{model_name},
                system_prompt => "You are a professional summarizer.",
                user_message  => $summary_prompt_safe,
            );
            @convo = (qq[CONVERSATION SUMMARY:] . $summary);
            $output
              = "collect: Conversation has been collected and summarized.";
        }
        catch {
            my $error = $_;
            $output = "ERROR: Running ,collect failed with message: $error";
        };
        push @convo, $output;
        say $output;
    },
    apply_patch => sub {
        my ($raw_args) = @_;
        my @args       = split / /, $raw_args;
        my $filename   = shift @args;
        my $diff_text  = join ' ', @args;

        $diff_text =~ s/<<<<<<< ORIGINAL/\n<<<<<<< ORIGINAL\n/g;
        $diff_text =~ s/=======/\n=======\n/g;
        $diff_text =~ s/>>>>>>> UPDATED/\n>>>>>>> UPDATED\n/g;

        $diff_text =~ s/<NL>/\n/g;

        if (DEBUG) {
            say STDERR qq[];
            say STDERR qq[DEBUG: apply_patch: args: ];
            say STDERR Dumper {filename => $filename,
                diff_text => $diff_text,};
            say STDERR qq[];
        }

        unless ($filename) {
            say "ERROR: No filename provided to ,apply_patch";
            return;
        }

        unless (-f $filename) {
            say qq[File '$filename' does not exist, will create new file];
            do { open(my $fh, '>', $filename) };
        }

        unless ($diff_text) {
            say "ERROR: No diff text provided to ,apply_patch";
            return;
        }

        # Security check: ensure filename is in a subdirectory of CWD
        my $abs_filename = File::Spec->rel2abs($filename);
        my $abs_cwd      = File::Spec->rel2abs($cwd);

        # Normalize paths to handle symlinks and .. components
        $abs_filename = Cwd::realpath($abs_filename) || $abs_filename;
        $abs_cwd      = Cwd::realpath($abs_cwd)      || $abs_cwd;

        # Check if the file is within CWD
        unless ($abs_filename =~ /^\Q$abs_cwd\E/) {
            say
              "ERROR: File '$filename' must be within current working directory";
            say "CWD: $abs_cwd";
            say "Requested: $abs_filename";
            return;
        }

        # Additional check: ensure it's actually in a
        # subdirectory, not CWD itself
        if ($abs_filename eq $abs_cwd) {
            say
              "ERROR: Cannot apply edits to the current working directory itself";
            return;
        }

        my $original_text = '';

        if (-f $filename) {
            try {
                $original_text = slurp($filename);
            }
            catch {
                say "ERROR: Could not read file '$filename': $_";
                return;
            };
        }

        # Extract edit blocks from the diff-fenced format
        my @edit_blocks;
        while (
            $diff_text =~ /[<]+ ORIGINAL\n(.*?)\n[=]+\n(.*?)\n[>]+ UPDATED/sg)
        {
            if (DEBUG) {
                say STDERR qq[];
                say STDERR qq[DEBUG: MATCH_ORIGINAL:  '$1'];
                say STDERR qq[DEBUG: MATCH_UPDATED: '$2'];
                say STDERR qq[];
            }
            push @edit_blocks, $1;
            push @edit_blocks, $2;
        }

        unless (@edit_blocks) {
            say "ERROR: No valid edit blocks found in diff text";
            return;
        }

        # Apply each edit block
        my $result      = $original_text;
        my $any_changes = 0;

        # Process blocks in pairs (search_text, replace_text)
        for (my $i = 0; $i < @edit_blocks; $i += 2) {

            my ($search_text, $replace_text) = @edit_blocks[$i .. $i + 1];

            # Strip any leading/trailing whitespace
            $search_text  =~ s/^\s+|\s+$//g;
            $replace_text =~ s/^\s+|\s+$//g;

            if (DEBUG) {
                say STDERR qq[];
                say STDERR qq[apply_patch: ],
                  Dumper {
                    search_text  => $search_text,
                    replace_text => $replace_text
                  };
                say STDERR qq[];
            }

            # Handle empty search text (append operation) Changed from `/
            # +/` to `/^\s*$/` The original regex `/ +/` matched ANY
            # string containing spaces, causing text with spaces (like "
            # old_line;" or "foo bar") to be appended instead of replaced
            # (SA: SYN-038). The correct check is for strings that are
            # ONLY whitespace.
            if ($search_text eq '' or $search_text =~ /^\s*$/) {
                $result .= $replace_text;
                $any_changes = 1;
            }

            # Normal replacement operation
            elsif ($result =~ /\Q$search_text\E/) {
                $result =~ s/\Q$search_text\E/$replace_text/;
                $any_changes = 1;
            }

            # Search text not found
            else {
                say "WARNING: Search text not found: '"
                  . substr($search_text, 0, 50) . "' ...";
            }
        }

        # Only write the file if we made changes
        if ($any_changes) {
            try {
                open my $fh, '>', $filename
                  or die "Cannot open '$filename' for writing: $!";
                print $fh $result;
                close $fh;
                my $output
                  = qq[apply_patch: Applied edits to file '$filename':\n];
                if ($agent_mode) {
                    $output .= qq[$diff_text\n];
                    push @convo, $output;
                }
                if ($agent_mode) {
                    $output = substr($output, 0, 50) . "...";
                }
                say $output;
            }
            catch {
                say "ERROR: Could not write to file '$filename': $_";
                return;
            };
        }
        else {
            say
              "INFO: No changes were applied to '$filename' (all search texts not found)";
        }
    },
    agent => sub {
        my ($task_description) = @_;
        unless ($task_description) {
            say "ERROR: No task provided to ,agent";
            say "Usage: ,agent <task description>";
            return;
        }

        # Don't allow agent mode when reading from STDIN (non-interactive)
        if (-p STDIN) {
            say "ERROR: Agent mode is not available in non-interactive mode";
            return;
        }

        $agent_mode = 1;
        say "AGENT MODE: Starting task: $task_description";
        say "Press Ctrl-C to interrupt at any time.\n";

        while ($agent_mode) {
            state $count = 0;

            my $ctx = build_prompt_context(
                ai_comm_is_base64 => $ai_comm_is_base64,
                convo             => \@convo,
                context           => \@context,
                sep               => $CONV_SEP,
            );

            my $convo_desc      = $ctx->{convo_desc};
            my $context_desc    = $ctx->{context_desc};
            my $block_start     = $ctx->{block_start};
            my $convo_content   = $ctx->{convo_content};
            my $context_content = $ctx->{context_content};
            my $block_end       = $ctx->{block_end};

            # Construct the full agent-specific system prompt
            # dynamically on each turn.  This combines the base
            # prompt, the REPL's existing conversation/context, and
            # agent-specific guidelines.

            my $dynamic_agent_system_prompt_content
              = $base_system_prompt . <<"EOAGENTPROMPT";
Here is the history of the conversation to this point $convo_desc:
$block_start
$convo_content
$block_end

Here are the contents of the files under discussion $context_desc:
$block_start
$context_content
$block_end

We are collaborating on a task where you are operating autonomously in agent mode. Our task is: <<< $task_description >>>

**OPERATIONAL GUIDELINES for SYNERGY Agent Mode:**
The following guidelines (expressed as "DOs and DON'Ts") are crucial for effective operation and collaboration. Please follow them as closely as possible.

- DO read the AGENTS.md file in the currrent project, if one exists
- DO use the defined commands to explore local files that you need to complete your task
- DO output each command on its own line. This is especially important for ,apply_patch!
- DO use only single shell commands with `,exec`. Avoid shell pipes, wildcards, or redirection.
- DO review the outputs of the previously run commands, they're in the conversation history.
- DO explain your actions and decisions using the `,comment` command
- DO use the `,apply_patch` command to write and edit files, using smallest possible patches
- DO respond when the task is complete with: ',comment AGENT_COMPLETE: <brief summary>'. The summary should concisely state the problem solved, the key changes made, and any outstanding issues or follow-up recommendations. If it's more than one line, prepend each line with `,comment ...`.

---
**AVAILABLE COMMANDS:**
- ,exec <cmd>       (Run shell cmd: grep sed wc ls file find cat make head), e.g.,
                        - ,exec ls
                        - ,exec cat <file.txt>
                        - ,exec grep -n <pattern> <file.txt>
- ,apply_patch file.txt '<<<<<<< ORIGINAL
                         foo
                         =======
                         bar
                         >>>>>>> UPDATED'
                        - Apply patch in "Aider diff edit" format to file.txt
- ,comment <text>   (explain reasoning)

---
**CURRENT ENVIRONMENT:**
Working Directory: $cwd
EOAGENTPROMPT

            if (DEBUG) {
                say qq[];
                say qq[DEBUG: AGENT PROMPT];
                say qq[$dynamic_agent_system_prompt_content];
                say STDERR qq[];
            }

            my $retry_count = 0;
            my $success     = 0;
            my $command;

            while (!$success && $retry_count <= $MAX_RETRIES) {
                try {
                    if ($retry_count > 0) {
                        my $delay = BASE_DELAY * (2**($retry_count - 1));
                        say STDERR
                          qq[AGENT: Retry attempt $retry_count after $delay second(s)...]
                          unless -p STDIN;
                        sleep $delay;
                    }

                    my $agent_next_turn_prompt = <<"EOTURN";
SYNERGY, what is the next command we should execute? Please consider our overall task and current progress, and feel free to use `,comment` to explain your reasoning or immediate objective.
EOTURN
                    $command = call_assistant(
                        provider      => $current_provider,
                        api_key       => $api_key,
                        model         => $current_model_config->{model_name},
                        system_prompt => $dynamic_agent_system_prompt_content,
                        user_message  => qq[$agent_next_turn_prompt],
                    );
                    $command =~ s/<\｜end▁of▁sentence\｜>//;
                    $success = 1;
                    $api_calls++;
                }
                catch {
                    my $error = $_;
                    $retry_count++;

                    if ($retry_count <= $MAX_RETRIES) {
                        say STDERR
                          qq[AGENT: API call failed: $error - retrying ($retry_count/$MAX_RETRIES)]
                          unless -p STDIN;
                    }
                    else {
                        $command
                          = qq[AGENT_COMPLETE: API call failed after $MAX_RETRIES retries: $error];
                        say STDERR qq[$command] unless -p STDIN;
                        $agent_mode = undef;
                    }
                };
            }

            if ($command) {
                execute_agent_command($command);

                # After executing the command, capture the command
                # output and make it visible to the agent.
                my $last_convo_entry;
                if (@convo) {
                    $last_convo_entry = $convo[-1];
                }
                my $command_summary = "agent: executed '$command'";

                if ($last_convo_entry) {
                    $command_summary
                      .= "\nagent: result = '$last_convo_entry'";
                }

                push @convo, $command_summary;

                # Check for stop condition
                if ($command =~ /AGENT_COMPLETE:(.*)/s) {
                    my $summary = $1;
                    $summary =~ s/^\s+|\s+$//g;
                    say "\nagent: Task complete.";
                    say "Summary: $summary" if $summary;
                    $agent_mode = undef;
                    last;
                }
            }
            else {
                say qq[WARNING: command was not defined! agent did not reply];
            }

            # Brief pause for UX (unless in fast mode)
            sleep 1 unless $ENV{SYNERGY_AGENT_FAST};

            # Check if user wants to interrupt
            if ($sigint_recvd) {
                $sigint_recvd = 0;
                print
                  "\nAGENT MODE: Interrupted by user. Continue agent? (y/n): ";
                my $response = <STDIN>;
                chomp $response if defined $response;

                if (defined $response && lc($response) ne 'y') {
                    say "AGENT MODE: Stopped by user.";
                    last;
                }
                else {
                    say "AGENT MODE: Continuing...";
                }
            }
        }
        print $user_shell_prompt;
    },
    inspect => sub {
        if (-p STDIN) {
            say "ERROR: ,inspect is only available in interactive mode";
            return;
        }

        # Trap process exit to prevent accidental shutdown
        local *CORE::GLOBAL::exit = sub { die "__SYNERGY_INSPECT_EXIT__\n" };

        # Configure Dumper for readable, clean output
        local $Data::Dumper::Terse    = 1;
        local $Data::Dumper::Indent   = 1;
        local $Data::Dumper::Sortkeys = 1;
        local $Data::Dumper::Pad      = '  ';

        say
          "[Entering SYNERGY Inspector - type ',q' to return, ',?' for help]";

        my $inspector_helptext = <<"EOF";
This is the Synergy Inspector. Type the name of a variable from the
program to see its value.

Commands:
,q			quit
,?			print help text
EOF

      LINE: while (1) {
            print "INSPECT > ";
            my $line = <STDIN>;
            last unless defined $line;
            $line =~ s/^\s+|\s+$//g;

            next if $line eq '';
            last if $line =~ /^(,q)$/i;

            if ($line =~ /^(,\?)$/) { say $inspector_helptext; next LINE; }

            try {
                # Evaluate in list context to capture arrays/hashes fully
                # We use 'do' to allow for complex expressions
                my @res
                  = eval "package main; no strict; no warnings; do { $line }";

                if ($@) {

                    # If they tried to call exit(), don't crash, just complain
                    if ($@ =~ /__SYNERGY_INSPECT_EXIT__/) {
                        say "  [Blocked attempt to exit process]";
                    }
                    else {
                        chomp(my $err = $@);
                        say "  ERROR: $err";
                    }
                }
                else {
                    # Dump the results. If list context has multiple items,
                    # Dumper will represent them as $VAR1, $VAR2, etc.
                    print Data::Dumper::Dumper(\@res);
                }
            }
            catch {
                chomp(my $err = $_);
                say "  CRITICAL ERROR: $err";
            };
        }

        say "Returned to SYNERGY REPL";
        return;
    },
};

sub build_prompt_context {
    my (%args)            = @_;
    my $ai_comm_is_base64 = $args{ai_comm_is_base64};
    my $convo_aref        = $args{convo}   // [];
    my $context_aref      = $args{context} // [];
    my $sep               = $args{sep}     // "\n===\n";

    my ($convo_content, $context_content);
    my ($convo_desc,    $context_desc);
    my ($block_start,   $block_end);

    if ($ai_comm_is_base64) {
        $convo_desc   = '(base64 encoded)';
        $context_desc = '(base64 encoded)';
        $block_start  = '{{{';
        $block_end    = '}}}';

        $convo_content
          = @$convo_aref
          ? encode_base64(encode("UTF-8", join($sep, @$convo_aref)))
          : '';
        $context_content
          = @$context_aref
          ? encode_base64(encode("UTF-8", join($sep, @$context_aref)))
          : '';
    }
    else {
        $convo_desc   = '(plain text)';
        $context_desc = '(plain text)';
        $block_start  = '```';
        $block_end    = '```';

        $convo_content   = @$convo_aref   ? join($sep, @$convo_aref)   : '';
        $context_content = @$context_aref ? join($sep, @$context_aref) : '';
    }

    return {
        convo_content   => $convo_content,
        context_content => $context_content,
        convo_desc      => $convo_desc,
        context_desc    => $context_desc,
        block_start     => $block_start,
        block_end       => $block_end,
    };
}

# Do not enable autodump mode if SYNERGY is being controlled from
# STDIN. This is necessary for the following reasons:
#
# First, it breaks the deterministic dump/load format e2e tests, since
# SYNERGY is autodumping and therefore the files are changing out from
# underneath the tests (specifically, I think the PIDs and timestamps
# are getting changed during the dump).  We want those tests to be
# deterministic, since they use data files that are checked into git.
#
# Second, when SYNERGY is driven as a subprocess over STDIN by the
# future "agent mode" (not yet implemented), the agents will not need
# to autodump their histories. At least, that is our current
# understanding, which may change.
$auto_dump_mode++ unless -p STDIN;

# This override should only be used by our e2e test suite that
# drives SYNERGY as a subprocess.
$auto_dump_mode++ if $ENV{SYNERGY_FORCE_AUTODUMP};

unless (-p STDIN) {

    # https://patorjk.com/software/taag/
    # Font: Standard
    print <<"EOBANNER";

  ░██████   ░██     ░██ ░███    ░██ ░██████████ ░█████████    ░██████  ░██     ░██ 
 ░██   ░██   ░██   ░██  ░████   ░██ ░██         ░██     ░██  ░██   ░██  ░██   ░██  
░██           ░██ ░██   ░██░██  ░██ ░██         ░██     ░██ ░██          ░██ ░██   
 ░████████     ░████    ░██ ░██ ░██ ░█████████  ░█████████  ░██  █████    ░████    
        ░██     ░██     ░██  ░██░██ ░██         ░██   ░██   ░██     ██     ░██     
 ░██   ░██      ░██     ░██   ░████ ░██         ░██    ░██   ░██  ░███     ░██     
  ░██████       ░██     ░██    ░███ ░██████████ ░██     ░██   ░█████░█     ░██     

@@@@@@@@@##*#****#***#############%#########*#%######%##%#*######%%%%%
@@@@@@%%%###**#****###########%###########%%##%%########%#*###########
%%##%%%%%%#****#**#########%##########################################
@@@@@@%%#%*******########%#######*+==----=+****#***********###########
@@@@@%%*##********#####%###*=-------=+*+=--=****#*************########
@@%%##**##********#####+=--------=+*+--=====+****##***********########
##%%%%*#*#*********#*=====++--------=+*****##****##*###******#########
@@%####**************=----==-==-----=*****++=+****##*********#########
@%##**#++***********#+-+****+===----=====----=+******##****###########
%@@@%#%#++*#**************+**=-=--------------=+*******###############
@@@@@@@*#%*#***********--------==--------------=*********#**##########
@%%%%%@#%##%#**********=-------==--------------=+*****################
@%%%%@@%%%#************+-------==--===---------=+*****################
%%%%%@@@%####***********=-------===------------=+*****#*##############
@%%%%@%##%##************+-----------=+****#*=--=+*******##############
@#%%@@@%#*******#********+------=*###*=-=*#=---=+********#############
%%%@@@@@@@%%%%%***********+----=*+----+##%+---==**********############
%%%@@@@@@@@@%***************=----+#%%####=----=+**********############
@#@@@@@@@@%#**************#***=----=++=-------=+*#*********##########%
#%@@@@@@@%****************#*****=------------==++++********###########
#%@@%%%%%********#*******#********=--------==+========+*****##########
%%#%%%@@#*******##*******#**********+=---===============*****#########
@@@@%%%%********##*******#*************+=================+*****#######
%%%@@@@%*********#*******#******#******+==================+******#####
@@@@@@@@%******%####*****#******###*****===================****###****
@@@@@@@@@%******###*******#*****###*##**+==================*##******#*
@@@@@@@@%#####*####*********####*#######*=============+*************++
@@@@@@%%%***********************########*======++*****************++++
EOBANNER
    print "Session ID: $session_id\n";
    print "Log file: $logfile\n";
}

print $user_shell_prompt unless -p STDIN;

LINE: while (<>) {
    state $just_ran_command;

    # This has to be redefined *after* hash initialization to include
    # the call to ,dump. The `exit` subroutine cannot call the `dump`
    # subroutine in another hash element, because technically the
    # latter does not exist yet until post-init.
    $cmd_lookup->{exit} = sub {
        if ($auto_dump_mode) {
            ## If autodump is enabled, ensure we have a target file and dump on exit.
            ## If the user never ran ,dump (or anything else that sets
            ## $active_dump_file), pick a fresh autodump filename now.
            if (!$active_dump_file) {
                my $next_uuid = generate_uuid();
                my $next_ts   = time;
                my $next_name = qq[$next_uuid.$next_ts.xml];

                my $maybe_dump_dir = qq[$synergy_root/etc/dumps];
                $active_dump_file
                  = (-e -d $maybe_dump_dir)
                  ? qq[$maybe_dump_dir/$next_name]
                  : $next_name;
            }

            $cmd_lookup->{dump}->($active_dump_file);
        }

        print "Goodbye!\n";
        exit 0;
    };

    # Check for pending SIGINT at the start of each loop iteration
    if ($sigint_recvd && !(-p STDIN)) {
        $sigint_recvd = 0;    # Reset flag
        print "\nDo you really want to quit SYNERGY? (y/n): ";

        my $response = <STDIN>;
        chomp $response if defined $response;

        if (defined $response && lc($response) eq 'y') {
            print "Goodbye!\n";
            if ($active_dump_file) {
                $cmd_lookup->{dump}->($active_dump_file);
            }
            exit 0;
        }
        else {
            print "Continuing...\n";
            print $user_shell_prompt;
            next LINE;
        }
    }

    my $input_line = $_;
    chomp(my $question = $input_line);

    # Print a warning and return to the REPL prompt without making an
    # API call if the question is empty or entirely whitespace.
    if ($question =~ /^\s*$/) {
        say "WARNING: Ignoring empty assistant query";
        unless (-p STDIN) {
            print $user_shell_prompt;
        }
        next LINE;
    }

    my $ctx = build_prompt_context(
        ai_comm_is_base64 => $ai_comm_is_base64,
        convo             => \@convo,
        context           => \@context,
        sep               => $CONV_SEP,
    );

    my $convo_desc      = $ctx->{convo_desc};
    my $context_desc    = $ctx->{context_desc};
    my $block_start     = $ctx->{block_start};
    my $convo_content   = $ctx->{convo_content};
    my $context_content = $ctx->{context_content};
    my $block_end       = $ctx->{block_end};


    $system_prompt = $base_system_prompt . <<"EOCONTEXT";
Here is the history of the conversation to this point $convo_desc:
$block_start
$convo_content
$block_end

Here are the contents of the files under discussion $context_desc:
$block_start
$context_content
$block_end
EOCONTEXT

    # When the user enters 'command mode', I should not send any input
    # to the assistant. Instead, I should only process user
    # commands. However, there should be no access to command mode
    # when I get input from STDIN, since those inputs are essentially
    # "one-shot" requests.

    do {
        my $command_mode;

        # This regular expression not only determines: do we enter
        # command mode? It also determines what characters are allowed
        # to be passed through as arguments to the various REPL
        # commands. The ,exec command in particular then has to do its
        # own shell metacharacter filtering out of some things that
        # are allowed in here, such as e.g. the semicolon. The
        # ,apply_patch command also has to allow in arbitrary text in
        # order to edit various file types, hence the growth of the
        # third capture group over time.
        if ($question
            =~ /^( +)?,([a-zA-Z\_]+)?( +[ a-zA-Z0-9\@\/\.\-\_\"\' \,\;\`\<\>\=\n\#\!\\\:\(\)\$\[\]\{\}\|\^\?\*]+)?/
          )
        {

            # do commands ...
            my $maybe_command = $2;
            my $maybe_arg     = $3;

            if (DEBUG) {
                say STDERR qq[];
                say STDERR qq[DEBUG: Command mode args: ];
                say STDERR Dumper {
                    maybe_command => $maybe_command,
                    maybe_arg     => $maybe_arg
                };
                say STDERR qq[];
            }

            if (   $maybe_command
                && $maybe_arg
                && exists $cmd_lookup->{$maybe_command})
            {
                $command_mode++;
                $maybe_arg =~ s/^ +//;
                $cmd_lookup->{$maybe_command}->($maybe_arg);
            }
            elsif ($maybe_command && exists $cmd_lookup->{$maybe_command}) {
                $command_mode++;
                $cmd_lookup->{$maybe_command}->();
            }
            else {
                $command_mode++;
                $cmd_lookup->{'help'}->();
            }
        }

        # ... and return for next REPL input ...

        if ($command_mode) {
            $just_ran_command = 1;
            unless (-p STDIN) {    # Only print prompt in interactive mode
                print $user_shell_prompt;
                $just_ran_command = undef;
            }
            next LINE;
        }
    };

    my $start = time;
    say qq[$synergy_shell_prompt thinking ...] unless -p STDIN;

    my $answer;
    my $retry_count = 0;
    my $success     = 0;

    while (!$success && $retry_count <= $MAX_RETRIES) {
        try {
            if ($retry_count > 0) {
                ## Exponential backoff
                my $delay = BASE_DELAY * (2**($retry_count - 1));
                say STDERR
                  qq[Retry attempt $retry_count after $delay second(s)...]
                  unless -p STDIN;
                sleep $delay;
            }

            my $input_line_safe = escape_raw_input($input_line);
            $answer = call_assistant(
                provider      => $current_provider,
                api_key       => $api_key,
                model         => $current_model_config->{model_name},
                system_prompt => $system_prompt,
                user_message  => $input_line_safe,
            );
            $answer =~ s/<\｜end▁of▁sentence\｜>//;
            $success = 1;
        }
        catch {
            my $error = $_;
            $retry_count++;

            if ($retry_count <= $MAX_RETRIES) {
                say STDERR
                  qq[API call failed: $error - retrying ($retry_count/$MAX_RETRIES)]
                  unless -p STDIN;
            }
            else {
                $answer
                  = qq[API call failed after $MAX_RETRIES retries: $error];
                say STDERR qq[$answer] unless -p STDIN;
            }
        };
    }

    $just_ran_command = 1;
    my $end = time;
    $api_calls++;
    print $answer;
    append_to_log(
        qq[## [sid:$session_id] [pid:$$] ($start) $user_shell_prompt $question]
    );
    append_to_log(
        qq[### [sid:$session_id] [pid:$$] ($end) $synergy_shell_prompt $answer]
    );
    push @convo, qq[$user_shell_prompt $question];
    push @convo, qq[$synergy_shell_prompt $answer];

    unless (-p STDIN) {
        printf(
            "\n -- %.3f seconds (%s)\n",
            ($end - $start),
            $current_model_config->{model_name}
        );
        print $just_ran_command ? $user_shell_prompt : $synergy_shell_prompt;
        $just_ran_command = undef;
    }
}

# If the REPL loop terminated due to EOF (Ctrl-D) in interactive mode,
# (and if there's an active dump file), save the conversation.
if ($auto_dump_mode && $active_dump_file) {

    # Print to STDERR to avoid polluting STDOUT, which might be piped
    print STDERR
      "INFO: Ctrl-D detected. Auto-saving conversation to '$active_dump_file'...\n";
    $cmd_lookup->{dump}->($active_dump_file);
}

sub generate_uuid {
    return $uuid_generator ? $uuid_generator->create_str() : simple_uuid();
}

sub simple_uuid {
    return join(
        '-',
        sprintf( "%08x", int( rand(0xffffffff) ) ),
        sprintf( "%04x", int( rand(0xffff) ) ),
        sprintf( "%04x", int( rand(0xffff) ) ),
        sprintf( "%04x", int( rand(0xffff) ) ),
        sprintf(
            "%04x%08x",
            int( rand(0xffff) ),
            int( rand(0xffffffff) )
        ),
    );
}

sub call_assistant {
    my (%args) = @_;
    my $provider      = $args{provider};
    my $api_key       = $args{api_key};
    my $model         = $args{model};
    my $system_prompt = $args{system_prompt} // '';
    my $user_message  = $args{user_message}  // '';

    if ($ENV{SYNERGY_OFFLINE}) {
        return offline_response();
    }

    my $provider_def = provider_def($provider);

    if ($ENV{SYNERGY_CURL_STUB}) {
        my $stub_body = slurp($ENV{SYNERGY_CURL_STUB});
        return $provider_def->{parse}->($stub_body);
    }

    if (!$api_key) {
        die qq[Missing API key for provider '$provider'];
    }

    my $request = $provider_def->{build}->(
        api_key       => $api_key,
        model         => $model,
        system_prompt => $system_prompt,
        user_message  => $user_message,
    );

    my $json_body = $JSON->encode($request->{body});
    my $result    = curl_request(
        url     => $request->{url},
        headers => $request->{headers},
        body    => $json_body,
    );

    my $status = $result->{status_code};
    if ($status < 200 || $status >= 300) {
        my $preview = $result->{body} // '';
        $preview =~ s/\s+/ /g;
        $preview = substr($preview, 0, 400);
        die qq[HTTP $status: $preview];
    }

    return $provider_def->{parse}->($result->{body});
}

sub offline_response {
    return $ENV{SYNERGY_OFFLINE_RESPONSE} // '[SYNERGY_OFFLINE]';
}

sub provider_def {
    my ($provider) = @_;
    my %defs = (
        openai => {
            build => \&build_openai_request,
            parse => \&parse_openai_response,
        },
        anthropic => {
            build => \&build_anthropic_request,
            parse => \&parse_anthropic_response,
        },
        gemini => {
            build => \&build_gemini_request,
            parse => \&parse_gemini_response,
        },
    );

    die qq[Unknown provider '$provider'] unless $defs{$provider};
    return $defs{$provider};
}

sub build_openai_request {
    my (%args) = @_;
    my $api_key       = $args{api_key};
    my $model         = $args{model};
    my $system_prompt = $args{system_prompt} // '';
    my $user_message  = $args{user_message}  // '';

    my @messages;
    if (length $system_prompt) {
        push @messages, { role => 'system', content => $system_prompt };
    }
    push @messages, { role => 'user', content => $user_message };

    my %body = (
        model    => $model,
        messages => \@messages,
        stream   => JSON::PP::false,
    );

    return {
        url     => 'https://api.openai.com/v1/chat/completions',
        headers => [
            'Content-Type: application/json',
            'Authorization: Bearer ' . $api_key,
        ],
        body => \%body,
    };
}

sub build_anthropic_request {
    my (%args) = @_;
    my $api_key       = $args{api_key};
    my $model         = $args{model};
    my $system_prompt = $args{system_prompt} // '';
    my $user_message  = $args{user_message}  // '';

    my %body = (
        model      => $model,
        messages   => [ { role => 'user', content => $user_message } ],
        max_tokens => 8192,
    );
    $body{system} = $system_prompt if length $system_prompt;

    return {
        url     => 'https://api.anthropic.com/v1/messages',
        headers => [
            'Content-Type: application/json',
            'x-api-key: ' . $api_key,
            'anthropic-version: 2023-06-01',
        ],
        body => \%body,
    };
}

sub build_gemini_request {
    my (%args) = @_;
    my $api_key       = $args{api_key};
    my $model         = $args{model};
    my $system_prompt = $args{system_prompt} // '';
    my $user_message  = $args{user_message}  // '';

    my @contents;
    if (length $system_prompt) {
        push @contents, {
            role  => 'user',
            parts => [ { text => $system_prompt } ],
        };
    }
    push @contents,
      { role => 'user', parts => [ { text => $user_message } ] };

    my %body = (
        contents         => \@contents,
        generationConfig => {
            maxOutputTokens => 8192,
        },
    );

    my $url
      = 'https://generativelanguage.googleapis.com/v1beta/models/'
      . $model
      . ':generateContent?key='
      . $api_key;

    return {
        url     => $url,
        headers => ['Content-Type: application/json'],
        body    => \%body,
    };
}

sub parse_openai_response {
    my ($body) = @_;
    my $data = decode_json_response($body);
    my $content = $data->{choices}[0]{message}{content};
    die "OpenAI response missing content" unless defined $content;
    return $content;
}

sub parse_anthropic_response {
    my ($body) = @_;
    my $data = decode_json_response($body);
    my $content = $data->{content}[0]{text};
    die "Anthropic response missing content" unless defined $content;
    return $content;
}

sub parse_gemini_response {
    my ($body) = @_;
    my $data = decode_json_response($body);
    my $content = $data->{candidates}[0]{content}{parts}[0]{text};
    die "Gemini response missing content" unless defined $content;
    return $content;
}

sub decode_json_response {
    my ($body) = @_;
    my $data;
    try {
        $data = $JSON->decode($body);
    }
    catch {
        my $error = $_;
        my $preview = $body // '';
        $preview =~ s/\s+/ /g;
        $preview = substr($preview, 0, 200);
        die qq[Failed to parse JSON response: $error (body: $preview)];
    };
    return $data;
}

sub curl_request {
    my (%args) = @_;
    my $url     = $args{url};
    my $headers = $args{headers} // [];
    my $body    = $args{body}    // '';

    my ( $req_fh,  $req_file )  = tempfile( 'synergy_req_XXXX',  TMPDIR => 1 );
    my ( $resp_fh, $resp_file ) = tempfile( 'synergy_resp_XXXX', TMPDIR => 1 );
    my ( $err_fh,  $err_file )  = tempfile( 'synergy_err_XXXX',  TMPDIR => 1 );

    print $req_fh $body;
    close $req_fh;
    close $resp_fh;
    close $err_fh;

    my @cmd = (
        'curl',
        '--silent',
        '--show-error',
        '--write-out',
        '%{http_code}',
        '--output',
        $resp_file,
        '--request',
        'POST',
        '--data-binary',
        "\@$req_file",
        '--stderr',
        $err_file,
    );
    for my $header (@$headers) {
        push @cmd, '--header', $header;
    }
    push @cmd, $url;

    open my $curl_fh, '-|', @cmd
      or die "ERROR: failed to execute curl: $!";
    my $http_code = do { local $/; <$curl_fh> };
    close $curl_fh;
    my $exit_code = $? >> 8;

    my $stderr = slurp($err_file);
    my $resp_body = slurp($resp_file);

    unlink $req_file;
    unlink $resp_file;
    unlink $err_file;

    if ($exit_code != 0) {
        die qq[curl failed (exit $exit_code): $stderr];
    }

    $http_code //= '';
    $http_code =~ s/\s+//g;
    if ($http_code !~ /^\d+$/) {
        die qq[curl failed to return HTTP status code];
    }

    return {
        status_code => int($http_code),
        body        => $resp_body,
        stderr      => $stderr,
    };
}

sub escape_raw_input {
    my ($s) = @_;
    $s =~ s/\\/\\\\/g;
    $s =~ s/"/\\"/g;
    $s =~ s/\n/\\n/g;
    $s =~ s/\r/\\r/g;
    $s =~ s/\t/\\t/g;
    $s =~ s/\f/\\f/g;
    $s =~ s/\b/\\b/g;
    $s =~ s/</\\u003C/g;
    $s =~ s/>/\\u003E/g;
    return $s;
}

sub sigint_handler {
    if ($agent_mode) {
        $agent_mode = undef;
        print
          "\nAGENT MODE: Interrupted by user. Returning control to REPL.\n";
        print $user_shell_prompt;
    }
    else {
        $sigint_recvd = 1;
    }
}

sub append_to_log {
    my ($msg) = @_;
    open my $fh, '>>', $logfile
      or die qq[$0: Can't open logfile '$logfile': $!\n];
    say $fh $msg;
    close $fh;
}

sub file_eq {
    my ($path1, $path2) = @_;

    my @stat1 = stat($path1);
    unless (@stat1) {
        warn "stat failed for '$path1': $!";
        return;
    }

    my @stat2 = stat($path2);
    unless (@stat2) {
        warn "stat failed for '$path2': $!";
        return;
    }

    # Compare device (index 0) and inode (index 1)
    return ($stat1[0] == $stat2[0] && $stat1[1] == $stat2[1]);
}

sub execute_agent_command {
    my ($command) = @_;

    # Special handling to allow apply_patch to handle multi-line diff
    # fenced edits as input from the agent.
    if ($command =~ /^,(apply_patch)\s+(\S+)\s+'(.*)$/s) {
        my $cmd_name      = 'apply_patch';
        my $filename      = $2;
        my $patch_content = $3;

        # Check if we have the complete patch (ends with closing quote
        # after UPDATED marker)
        if ($patch_content =~ />>>>>>> UPDATED'\s*$/s) {
            $cmd_lookup->{$cmd_name}->($filename . ' ' . $patch_content);
        }
        else {
            # We need to accumulate more lines - read from the string handle
            my $bytes = encode('UTF-8', $command);
            open my $sh, '<', \$bytes
              or die qq[can not open string handle on '$command': $!];

            my $accumulated_patch = $patch_content;
            my $found_end         = 0;

            while (<$sh>) {
                $accumulated_patch .= $_;
                if (/>>>>>>> UPDATED'\s*$/) {
                    $found_end = 1;
                    last;
                }
            }
            close $sh;

            if ($found_end) {
                $cmd_lookup->{$cmd_name}
                  ->($filename . ' ' . $accumulated_patch);
            }
            else {
                say
                  "AGENT ERROR: Incomplete apply_patch command - missing closing marker";
                push @convo, qq[AGENT ERROR: Incomplete apply_patch command];
            }
        }

        if ($auto_dump_mode && $active_dump_file) {
            $cmd_lookup->{dump}->($active_dump_file);
        }
        return;
    }

    # Parse the command to determine if it's a REPL command or regular input
    my $command_pat = qr[^,([a-zA-Z_]+)(?:\s+(.*))?$];

    # Try single-line parsing first
    if ($command =~ /$command_pat/) {
        my $cmd_name = $1;
        my $cmd_args = $2 // '';

        # Check if this is a valid REPL command
        if (exists $cmd_lookup->{$cmd_name}) {

            # Execute the command through the existing command infrastructure
            if ($cmd_args) {
                $cmd_lookup->{$cmd_name}->($cmd_args);
            }
            else {
                $cmd_lookup->{$cmd_name}->();
            }
        }
        else {
            say "AGENT ERROR: Unknown command ',$cmd_name'";
            push @convo, qq[AGENT ERROR: Unknown command ',$cmd_name'];
        }
    }
    else {
        # If single-line parsing failed, try line-by-line parsing.  This
        # handles multi-line responses that contain commands mixed with
        # text.

        # Fix the error "Strings with code points over 0xFF may not be
        # mapped into in-memory file handles" in SID
        # AC4E62F6-AB8B-11F0-8381-BEFDF5F59C27
        my $bytes = encode('UTF-8', $command);
        open my $sh, '<', \$bytes
          or die qq[can not open string handle on '$command': $!];

        my ($cmd_name, $cmd_args);
        my $inside_apply_patch = 0;
        my $in_patch_block     = 0;
        my $patch_accumulator  = '';
        my $filename;

      L: while (<$sh>) {
            my $line = $_;

            # Special handling for apply_patch command with multi-line patches
            if ($line =~ /^,(apply_patch)\s+(\S+)\s+'<<<<<<< ORIGINAL/) {
                $cmd_name          = 'apply_patch';
                $filename          = $2;
                $in_patch_block    = 1;
                $patch_accumulator = "<<<<<<< ORIGINAL\n";
                next L;
            }

        # If we're accumulating a patch, continue until we find the end marker
            if ($in_patch_block) {
                $patch_accumulator .= $line;
                if ($line =~ /^>>>>>>> UPDATED'/) {
                    $cmd_args = $filename . ' ' . $patch_accumulator;
                    goto EXECUTE;
                }
                next L;
            }

           # Legacy handling for apply_patch (kept for backward compatibility)
            if ($line =~ /[>]+ UPDATED/) {
                $inside_apply_patch = undef;
                $cmd_args .= $line;
                $cmd_args = qq[$cmd_args '];
                goto EXECUTE;
            }

            # Standard command pattern matching
            if ($line =~ /$command_pat/) {
                $cmd_name = $1;
                $cmd_args = $2 // '';

                if ($cmd_name eq 'apply_patch') {
                    $inside_apply_patch++;
                }
                else {
                    $inside_apply_patch = undef;
                }
            }
            else {
                # Handle continuation lines for apply_patch
                if ($inside_apply_patch) {
                    $cmd_args .= $line;
                }
                next L;
            }

          EXECUTE:
            if (exists $cmd_lookup->{$cmd_name}) {
                if ($cmd_args) {
                    $cmd_lookup->{$cmd_name}->($cmd_args);
                }
                else {
                    $cmd_lookup->{$cmd_name}->();
                }
            }
            else {
                say "AGENT ERROR: Unknown command ',$cmd_name'";
                push @convo, qq[AGENT ERROR: Unknown command ',$cmd_name'];
            }
        }
        close $sh;
    }

    # Auto-dump must happen before the next agent command.  This
    # ensures command output is in the context when building the next
    # prompt.
    if ($auto_dump_mode && $active_dump_file) {
        $cmd_lookup->{dump}->($active_dump_file);
    }
}

=head1 Synergy - a read-eval-print loop (REPL) for AI assistants

From L<https://jem.fandom.com/wiki/Synergy>:

I<Synergy is a highly technologically advanced artificial intelligence.  She can understand what others say and still have her own opinions.>

=head2 Overview

Synergy is a REPL for talking to AI assistants. It is designed for both interactive and non-interactive use from the command line.

There are two "modes" for interacting with Synergy: interactive mode, which provides a REPL; and non-interactive mode, which is when you're talking to Synergy over a pipe.

=head3 Interactive mode (REPL)

If you go to the Terminal and start C<synergy>, a prompt appears. You can type questions at the prompt, and they will be sent to the AI assistant. The assistant's responses will be printed out. For example:

    $ synergy
    USER > i am writing perl documentation in the POD format (a README), how do i represent a quotation / blockquote?
    (1741177286.90149) thinking ...
    In Perl's POD (Plain Old Documentation) format, you can represent a quotation or blockquote using the `=begin` and `=end` blocks with the `text` format. Here's an example: ...

Synergy also accepts special commands starting with a comma. These commands are not sent to the AI assistant. Instead, they control the state of the REPL. For example, you can add a text file into the context of the current conversation, or serialize the current session to disk as an XML file.

When you add a file to the context, it is stored in a stack. There are several stack manipulation commands for pushing, popping, rotating, etc.

=head3 Noninteractive mode (input via pipe)

The simplest way to talk to Synergy is via one-shot commands over a pipe

    $ echo "Please write a haiku in the style of Li Po about what it's like to be an artificial intelligence" | synergy
    Here's a haiku in the style of Li Po, capturing the essence of an AI's experience:

    Moonlight of data
    Flowing through circuits of thought
    No heart, yet I dream

    ...

=head3 Command processor commands

The complete list of special commands is documented in the interactive help output.

    $ synergy
    USER > ,help
    This is Synergy. You are interacting with the command processor.
    A command is either a prose form for the Assistant to evaluate or one of the following:

    General commands:
    ,help ,?			Print this help message
    ,exit				Quit the SYNERGY command processor

    History Management:
    ,history			Print out the conversation history so far
    ,reset				Discard conversation history and file context (A B C - )
    ,collect			Replace current conversation history with a summary

    File Context:
    ,s					Print contents of file context stack
    ,push file.txt		Push file.txt onto file context stack (B C - A B C)
    ,swap				Swap top two elements of file context stack (A B - B A)
    ,rot				Rotate file context stack entries (A B C - B C A)
    ,drop [N...]		Remove elements of file context stack:
                         - With no args: pop top stack element (A B C - B C)
                         - With arg N: remove element at index N (A B .. N - A B ..)
    ,peek N				View contents of Nth element of file context stack

    Session Management:
    ,dump file.xml		Save session history (including current file context stack, if any) to disk
    ,load file.xml		Load session history (including file context stack, if any) from disk

    System Interaction:
    ,pwd				Print current working directory
    ,cd /some/dir		Change working directory to /some/dir
    ,exec cmd			Execute shell command (grep sed wc ls file find cat make head)
                        Output is saved to conversation history

    Agent Interaction:
    ,agent <prompt>		Prompt the system to complete a task autonomously using this command set.
                        Agent has access to: ,exec ,apply_patch ,comment
                        Agent prints a summary of work when completed. Enter Ctrl-C to exit loop.
    ,apply_patch file.txt '<<<<<<< ORIGINAL
                           foo
                           =======
                           bar
                           >>>>>>> UPDATED'
                        Apply patch in diff-fenced edit format to file.txt
    ,comment			Write a comment that is printed back to the REPL's output.
                        This is useful for notes to self by humans or AI agents.

    Model Settings:
    ,model [name]       Print (or switch) the current model
                        - With no args: Print the current model and the list of options
                        - With name (e.g., `gpt-5`): Switch to model with that name
    ,encoded			Base64 encode contents of API calls to the Assistant (default ON)

=head3 Setup

The C<synergy> program is written in Perl, and uses a number of libraries that need to be installed. For now, see the source code for details.

You will need to provide an API key:

    $ export ANTHROPIC_API_KEY="ABC123..."

=head2 Credits

Credit for the design goes to:

=over

=item Scheme48

The command processor "look and feel", as well as the special command syntax and help output, are directly taken from Scheme48.

=item Forth

The file context stack manipulation commands are inspired by the Forth programming language.

=back

=cut

__END__
